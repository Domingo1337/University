#lang racket

;;; ---------------------------------------------------------------------------
;;; Prosty system obiektowy z dziedziczeniem

(define (ask object message . args)
  (let ((method (get-method object message)))
    (if (method? method)
	(apply method (cons object args))
	(error "Brak metody" message (cadr method)))))

(define (get-method object message)
  (object message))

(define (no-method name)
  (list 'no-method name))

(define (method? x)
  (not (no-method? x)))

(define (no-method? x)
  (if (pair? x)
      (eq? (car x) 'no-method)
      false))

;;; ----------------------------------------------------------------------------
;;; Osoby, miejsca i rzeczy sƒÖ nazwanymi obiektami

(define (make-named-object name)
  (lambda (message) 
    (cond ((eq? message 'name) (lambda (self) name))
	  (else (no-method name)))))

;;; Osoby i rzeczy sƒÖ mobilne, ich miejsce mo≈ºe ulec zmianie

(define (make-mobile-object name location)
  (let ((named-obj (make-named-object name)))
    (lambda (message)
      (cond ((eq? message 'place)    (lambda (self) location))
	    ((eq? message 'install)
	     (lambda (self)
	       (ask location 'add-thing self)))
	    ;; Poni≈ºsza metoda nie powinna byƒá wo≈Çana przez u≈ºytkownika
	    ;; Zobacz change-place
	    ((eq? message 'set-place)
	     (lambda (self new-place)
	       (set! location new-place)
	       'place-set))
	    (else (get-method named-obj message))))))

(define (make&install-mobile-object name place)
  (let ((mobile-obj (make-mobile-object name place)))
    (ask mobile-obj 'install)
    mobile-obj))

;;; Rzecz to co≈õ, co mo≈ºe mieƒá w≈Ça≈õciciela

(define (make-thing name birthplace)
  (let ((owner     'nobody)
	(mobile-obj (make-mobile-object name birthplace)))
    (lambda (message)
      (cond ((eq? message 'owner)    (lambda (self) owner))
	    ((eq? message 'ownable?) (lambda (self) true))
	    ((eq? message 'owned?)
	     (lambda (self)
	       (not (eq? owner 'nobody))))
	    ;; Poni≈ºsza metoda nie powinna byƒá wo≈Çana przez u≈ºytkownika
	    ;; Zobacz take i lose
	    ((eq? message 'set-owner)
	     (lambda (self new-owner)
	       (set! owner new-owner)
	       'owner-set))
	    (else (get-method mobile-obj message))))))

(define (make&install-thing name birthplace)	
  (let ((thing  (make-thing name birthplace)))
    (ask thing 'install)
    thing))

;;; Implementacja miejsc

(define (make-place name)
  (let ((neighbor-map '())		
	(things       '())
	(named-obj (make-named-object name)))
    (lambda (message)
      (cond ((eq? message 'things) (lambda (self) things))
	    ((eq? message 'neighbors)
	     (lambda (self) (map cdr neighbor-map)))
	    ((eq? message 'exits)
	     (lambda (self) (map car neighbor-map)))
	    ((eq? message 'neighbor-towards)
	     (lambda (self direction)
	       (let ((places (assq direction neighbor-map)))
		 (if places
		     (cdr places)
		     false))))
            ((eq? message 'add-neighbor)
             (lambda (self direction new-neighbor)
               (cond ((assq direction neighbor-map)
                      (display-message (list "Kierunek ju≈º przypisany"
					      direction name))
		      false)
                     (else
                      (set! neighbor-map
                            (cons (cons direction new-neighbor) neighbor-map))
		      true))))
	    ((eq? message 'accept-person?)
	     (lambda (self person)
	       true))
 
	    ;; Poni≈ºsze metody nie powinny byƒá wo≈Çane przez u≈ºytkownika
	    ;; Zobacz change-place
            ((eq? message 'add-thing)
             (lambda (self new-thing)
               (cond ((memq new-thing things)
                      (display-message (list (ask new-thing 'name)
					     "ju≈º jest w" name))
		      false)
                     (else (set! things (cons new-thing things))
			   true))))
            ((eq? message 'del-thing)
             (lambda (self thing)
               (cond ((not (memq thing things))
                      (display-message (list (ask thing 'name)
					     "nie jest w" name))
		      false)
                     (else (set! things (delq thing things))
			   true))))

            (else (get-method named-obj message))))))

;;; ----------------------------------------------------------------------------
;;; Implementacja os√≥b
;; funkcja pomocnicza
(define (cons-n n sym list)
  (if (< n 1) list
      (cons sym (cons-n (- n 1) sym list))))

(define (make-person name birthplace threshold [affection 0])
  (let ((possessions '())
	(mobile-obj  (make-mobile-object name birthplace)))
    (lambda (message)
      (cond ((eq? message 'person?)     (lambda (self) true))
	    ((eq? message 'possessions) (lambda (self) possessions))
	    ((eq? message 'list-possessions)
	     (lambda (self)
	       (ask self 'say
		    (cons "Mam"
			  (if (null? possessions)
			      '("nic")
			      (map (lambda (p) (ask p 'name))
				      possessions))))
	       possessions))
            ((eq? message 'print-affection)
             (lambda (self)
               (if (< affection 3) null (display "Brawo, uda≈Ço ci siƒô uwie≈õƒá "))
               (for-each (lambda (s) (display s) (display " "))
                         (cons (ask self 'name)
                               (cons ':
                                     (if (< affection 0) (list 'üíî)
                                         (cons-n affection 'üñ§ '())))))
               (newline)))
	    ((eq? message 'say)
	     (lambda (self list-of-stuff)
	       (display-message
		 (append (list "W miejscu" (ask (ask self 'place) 'name)
			       ":"  name "m√≥wi --")
			 (if (null? list-of-stuff)
			     '("Niewa≈ºne.")
			     list-of-stuff)))
	       'said))
	    ((eq? message 'have-fit)
	     (lambda (self)
	       (ask self 'say '("Bardzo proszƒô."))
	       'I-feel-better-now))
	    ((eq? message 'look-around)
	     (lambda (self)
	       (let ((other-things
		       (map (lambda (thing) (ask thing 'name))
                               (delq self
                                     (ask (ask self 'place)
                                          'things)))))
                 (ask self 'say (cons "Widzƒô" (if (null? other-things)
						  '("nic")
						  other-things)))
		 other-things)))
            ((eq? message 'give)
             (lambda (self thing)
               (if (and 
                    (let ((things-at-place (ask (ask self 'place) 'things)))
                      (memq thing things-at-place))
                    (ask thing 'owned?)
                    (eq? (ask (ask thing 'owner) 'name) 'student))
                   (and (set! affection (+ 1 affection))
                        (ask self 'take thing)
                        (newline)
                        (ask self 'print-affection)
                        #t)
                   (and (ask self 'say (list "Nie mo≈ºesz mi daƒá"
                                             (ask thing 'name)))
                        #f))))
            ((eq? message 'take)
	     (lambda (self thing)
	       (cond ((memq thing possessions)
		      (ask self 'say
			   (list "Ju≈º mam" (ask thing 'name)))
		      true)
		     ((and (let ((things-at-place (ask (ask self 'place) 'things)))
			     (memq thing things-at-place))
			   (is-a thing 'ownable?))
		      (if (ask thing 'owned?)
			  (let ((owner (ask thing 'owner)))
			    (ask owner 'lose thing)
			    (ask owner 'have-fit))
			  'unowned)

		      (ask thing 'set-owner self)
		      (set! possessions (cons thing possessions))
		      (ask self 'say
			   (list "Biorƒô" (ask thing 'name)))
		      true)
		     (else
		      (display-message
		       (list "Nie mo≈ºesz wziƒÖƒá" (ask thing 'name)))
		      false))))
	    ((eq? message 'lose)
	     (lambda (self thing)
	       (cond ((eq? self (ask thing 'owner))
		      (set! possessions (delq thing possessions))
		      (ask thing 'set-owner 'nobody) 
		      (ask self 'say
			   (list "Tracƒô" (ask thing 'name)))
		      true)
		     (else
		      (display-message (list name "nie ma"
					     (ask thing 'name)))
		      false))))
	    ((eq? message 'move)
	     (lambda (self)
               (cond ((and (> threshold 0) (= (random threshold) 0))
		      (ask self 'act)
		      true))))
	    ((eq? message 'act)
	     (lambda (self)
	       (let ((new-place (random-neighbor (ask self 'place))))
		 (if new-place
		     (ask self 'move-to new-place)
		     false))))

	    ((eq? message 'move-to)
	     (lambda (self new-place)
	       (let ((old-place (ask self 'place)))
		 (cond ((eq? new-place old-place)
			(display-message (list name "ju≈º jest w"
					       (ask new-place 'name)))
			false)
		       ((ask new-place 'accept-person? self)
			(change-place self new-place)
			(for-each (lambda (p) (change-place p new-place))
				  possessions)
			(display-message
			  (list name "idzie z"    (ask old-place 'name)
				     "do"         (ask new-place 'name)))
			(greet-people self (other-people-at-place self new-place))
			true)
		       (else
			(display-message (list name "nie mo≈ºe i≈õƒá do"
					       (ask new-place 'name))))))))
	    ((eq? message 'go)
	     (lambda (self direction)
	       (let ((old-place (ask self 'place)))
		 (let ((new-place (ask old-place 'neighbor-towards direction)))
		   (cond (new-place
			  (ask self 'move-to new-place))
			 (else
			  (display-message (list "Nie mo≈ºesz p√≥j≈õƒá" direction
						 "z" (ask old-place 'name)))
			  false))))))
	    ((eq? message 'install)
	     (lambda (self)
	       (add-to-clock-list self)
	       ((get-method mobile-obj 'install) self)))
	    (else (get-method mobile-obj message))))))
  
(define (make&install-person name birthplace threshold [affection 0])
  (let ((person (make-person name birthplace threshold affection)))
    (ask person 'install)
    person))

;;; ≈Åazik umie sam podnosiƒá rzeczy

(define (make-rover name birthplace threshold)
  (let ((person (make-person name birthplace threshold)))
    (lambda (message)
      (cond ((eq? message 'act)
	     (lambda (self)
	       (let ((possessions (ask self 'possessions)))
                 (if (null? possessions)
                     (ask self 'grab-something)
                     (ask self 'lose (car possessions))))))
            ((eq? message 'grab-something)
	     (lambda (self)
	       (let* ((things (ask (ask self 'place) 'things))
                      (fthings
                       (filter (lambda (thing) (is-a thing 'ownable?))
                               things)))
		 (if (not (null? fthings))
		     (ask self 'take (pick-random fthings))
		     false))))
	    ((eq? message 'move-arm)
	     (lambda (self)
               (display-message (list name "rusza manipulatorem"))
	       '*bzzzzz*))
	    (else (get-method person message))))))

(define (make&install-rover name birthplace threshold)
  (let ((rover  (make-rover name birthplace threshold)))
    (ask rover 'install)
    rover))

;; TODO: nowe rodzaje przedmiot√≥w lub postaci

;;; --------------------------------------------------------------------------
;;; Obs≈Çuga zegara

(define *clock-list* '())
(define *the-time* 0)

(define (initialize-clock-list)
  (set! *clock-list* '())
  'initialized)

(define (add-to-clock-list person)
  (set! *clock-list* (cons person *clock-list*))
  'added)

(define (remove-from-clock-list person)
  (set! *clock-list* (delq person *clock-list*))
  'removed)

(define (clock)
  (newline)
  (display "---Tick---")
  (set! *the-time* (+ *the-time* 1))
  (for-each (lambda (person) (ask person 'move))
	    *clock-list*)
  'tick-tock)
	     

(define (current-time)
  *the-time*)

(define (run-clock n)
  (cond ((zero? n) 'done)
	(else (clock)
	      (run-clock (- n 1)))))

;;; --------------------------------------------------------------------------
;;; R√≥≈ºne procedury

(define (is-a object property)
  (let ((method (get-method object property)))
    (if (method? method)
	(ask object property)
	false)))

(define (change-place mobile-object new-place)
  (let ((old-place (ask mobile-object 'place)))
    (ask mobile-object 'set-place new-place)
    (ask old-place 'del-thing mobile-object))
  (ask new-place 'add-thing mobile-object)
  'place-changed)

(define (other-people-at-place person place)
  (filter (lambda (object)
	    (if (not (eq? object person))
		(is-a object 'person?)
		false))
	  (ask place 'things)))

(define (greet-people person people)
  (if (not (null? people))
      (ask person 'say
	   (cons "Cze≈õƒá"
		 (map (lambda (p) (ask p 'name))
			 people)))
      'sure-is-lonely-in-here))

(define (display-message list-of-stuff)
  (newline)
  (for-each (lambda (s) (display s) (display " "))
	    list-of-stuff)
  'message-displayed)

(define (random-neighbor place)
  (pick-random (ask place 'neighbors)))

(define (filter predicate lst)
  (cond ((null? lst) '())
	((predicate (car lst))
	 (cons (car lst) (filter predicate (cdr lst))))
	(else (filter predicate (cdr lst)))))

(define (pick-random lst)
  (if (null? lst)
      false
      (list-ref lst (random (length lst)))))  ;; See manual for LIST-REF

(define (delq item lst)
  (cond ((null? lst) '())
	((eq? item (car lst)) (delq item (cdr lst)))
	(else (cons (car lst) (delq item (cdr lst))))))

;;------------------------------------------
;; Od tego miejsca zaczyna siƒô kod ≈õwiata

(initialize-clock-list)

;; Tu definiujemy miejsca w naszym ≈õwiecie
;;------------------------------------------

(define hol              (make-place 'hol))
(define piƒôtro-wsch√≥d    (make-place 'piƒôtro-wsch√≥d))
(define piƒôtro-zach√≥d    (make-place 'piƒôtro-zach√≥d))
(define ksi              (make-place 'ksi))
(define continuum        (make-place 'continuum))
(define plastyczna       (make-place 'plastyczna))
(define wielka-wschodnia (make-place 'wielka-wschodnia))
(define wielka-zachodnia (make-place 'wielka-zachodnia))
(define kameralna-wschodnia (make-place 'kameralna-wschodnia))
(define kameralna-zachodnia (make-place 'kameralna-zachodnia))
(define schody-parter    (make-place 'schody-parter))
(define schody-piƒôtro    (make-place 'schody-piƒôtro))

;; nowe lokacje
(define nadodrze (make-place 'nadodrze))
(define dziekanat (make-place 'dziekanat))
(define uniradio (make-place 'uni-radio))

;; Po≈ÇƒÖczenia miƒôdzy miejscami w ≈õwiecie
;;------------------------------------------------------

(define (can-go from direction to)
  (ask from 'add-neighbor direction to))

(define (can-go-both-ways from direction reverse-direction to)
  (can-go from direction to)
  (can-go to reverse-direction from))

(can-go-both-ways schody-parter 'g√≥ra 'd√≥≈Ç schody-piƒôtro)
(can-go-both-ways hol 'zach√≥d 'wsch√≥d wielka-zachodnia)
(can-go-both-ways hol 'wsch√≥d 'zach√≥d wielka-wschodnia)
(can-go-both-ways hol 'po≈Çudnie 'p√≥≈Çnoc schody-parter)
(can-go-both-ways piƒôtro-wsch√≥d 'po≈Çudnie 'wsch√≥d schody-piƒôtro)
(can-go-both-ways piƒôtro-zach√≥d 'po≈Çudnie 'zach√≥d schody-piƒôtro)
(can-go-both-ways piƒôtro-wsch√≥d 'zach√≥d 'wsch√≥d piƒôtro-zach√≥d)
(can-go-both-ways piƒôtro-zach√≥d 'p√≥≈Çnoc 'po≈Çudnie kameralna-zachodnia)
(can-go-both-ways piƒôtro-wsch√≥d 'p√≥≈Çnoc 'po≈Çudnie kameralna-wschodnia)
(can-go-both-ways schody-parter 'wsch√≥d 'zach√≥d plastyczna)
(can-go-both-ways hol 'p√≥≈Çnoc 'po≈Çudnie ksi)
(can-go-both-ways piƒôtro-zach√≥d 'zach√≥d 'wsch√≥d continuum)

;; po≈ÇƒÖczenia dla nowych lokacji
(can-go-both-ways wielka-wschodnia 'po≈Çudnie 'p√≥≈Çnoc dziekanat)
(can-go-both-ways plastyczna 'po≈Çudnie 'p√≥≈Çnoc nadodrze)
(can-go-both-ways uniradio 'p√≥≈Çnoc 'po≈Çudnie schody-piƒôtro)

;; Osoby dramatu
;;---------------------------------------

(define student   (make&install-person 'student hol 0))
(define fsieczkowski (make&install-person 'fsieczkowski wielka-wschodnia 3 1))
(define mpirog    (make&install-person 'mpirog wielka-wschodnia 3))
(define mmaterzok (make&install-person 'mmaterzok wielka-wschodnia 3))
(define jma       (make&install-person 'jma piƒôtro-wsch√≥d 2 -99))
(define klo       (make&install-person 'klo kameralna-wschodnia 2 -99))
(define ref       (make&install-person 'ref ksi 0))
(define aleph1    (make&install-rover 'aleph1 continuum 3))

(define s≈Ç√≥j-pacholskiego (make&install-thing 's≈Ç√≥j-pacholskiego schody-piƒôtro))
(define trytytki     (make&install-thing 'trytytki continuum))
(define cƒÖ≈ºki-boczne (make&install-thing 'cƒÖ≈ºki-boczne continuum))

;; dodatkowe osoby i przedmioty
(define twi               (make&install-person 'twi kameralna-wschodnia 0 -99))
(define dziennikarka      (make&install-person 'dziennikarka kameralna-zachodnia 1 2))
(define dziennikarz       (make&install-person 'dziennikarz uniradio 2))
(define studentka         (make&install-person 'studentka plastyczna 3 1))
(define pani-z-dziekanatu (make&install-person 'pani-z-dziekanatu dziekanat 0 1))

(define mio-mio-mate       (make&install-thing 'mio-mio-mate plastyczna))
(define kwiaty             (make&install-thing 'kwiaty nadodrze))
(define kanapka            (make&install-thing 'kanapka wielka-wschodnia))
(define czekolada          (make&install-thing 'czekolada kameralna-wschodnia))
(define kawa               (make&install-thing 'kawa kameralna-zachodnia))
(define indeks             (make&install-thing 'indeks dziekanat))
(define piosenka-o-mi≈Ço≈õci (make&install-thing 'piosenka-o-mi≈Ço≈õci uniradio))
;; Polecenia dla gracza
;;------------------------------------------------

(define *player-character* student)

(define (look-around)
  (ask *player-character* 'look-around)
  #t)
(define (go direction)
  (ask *player-character* 'go direction)
  (clock)
  #t)

(define (exits)
  (display-message (ask (ask *player-character* 'place) 'exits))
  #t)

;; dodatkowe polecenia dla gracza

(define (grab)
  (let* ((things (ask (ask *player-character* 'place) 'things))
         (fthings (filter (lambda (thing) (not (ask thing 'owned?)))
                          (filter (lambda (thing) (is-a thing 'ownable?))
                                  things))))
    (if (not (null? fthings))
        (and (ask *player-character* 'take (pick-random fthings))
             (clock))
        false)))
(define (check-inventory)
  (ask *player-character* 'list-possessions))
(define (give person thing)
  (ask person 'give thing))
(define (show-stats)
  (let ((people (list fsieczkowski mpirog mmaterzok jma klo ref aleph1
                      twi dziennikarka dziennikarz studentka pani-z-dziekanatu)))
    (and (map (lambda (person) (not (ask person 'print-affection))) people))
    (display "")))

(display "Cel gry: znale≈∫ƒá co najmniej jednƒÖ drugƒÖ po≈Ç√≥wkƒô")
